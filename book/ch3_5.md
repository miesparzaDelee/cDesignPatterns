## Family Pattern (Inheritance)

### Pattern Description

The Family Pattern (commonly known as Inheritance) allows multiple distinct objects to share a common set of behaviors and attributes. In C, this is achieved structurally by placing a "Base" structure as the **first member** of a "Derived" structure.

Because the Base member is at offset 0, a pointer to the Derived structure is binary-compatible with a pointer to the Base structure. This guarantees safe upcasting (treating a specific shape as a generic shape) and enables polymorphic behavior.

#### **Key Use Cases**

- When you have a collection of different objects that share common attributes (e.g., `color`, `visibility`, `type`).
- When you want to process different objects uniformly (e.g., an array of shapes to draw).
- To adhere to the **DRY (Don't Repeat Yourself)** principle by centralizing shared logic in the base class.

#### **Benefits**

- **Polymorphism**: Allows treating different types as a single generic type (`shape_t*`).
- **Code Reuse**: Shared initialization and logic (like color or visibility checks) live in the base class.
- **Type Safety**: The structure layout ensures that casting between Derived and Base is valid.

#### **Drawbacks**

- **Rigid Layout**: The Base struct *must* be the first member. This strict memory layout can limit flexibility.
- **Tight Coupling**: Changes to the Base struct (e.g., adding a field) affect the size and layout of *all* derived structs.

### Implementation

#### **Header Files**

The implementation requires a public Base struct and Derived structs that embed it.

First, the **Base** definition:

{{ file "companion_code/ch3_patterns/include/shape.h" type="whole" }}

Next, a **Derived** definition (e.g., Rectangle). Notice that `shape_t base` is the **first member** of `shape_rectangle_t`.

{{ file "companion_code/ch3_patterns/include/shape_rectangle.h" type="whole" }}

### Alternative Implementation

Instead of embedding `rectangle_t` directly, we could have stored a pointer `rectangle_t*`. However, embedding (Composition) allows for a single contiguous memory block, which is better for cache performance and avoids an extra allocation.

#### **Source Files**

The initialization process describes the "Family" relationship. The derived shape's init function is responsible for initializing **both** the base part and its specific part.

Consequently, the init function requires configuration for both:

1. **`shape_config_t`**: For the base attributes (color, type).
2. **`rect_config_t`**: For the specific attributes (width, height).

{{ file "companion_code/ch3_patterns/src/shape_rectangle.c" type="whole" }}

Notice the order: `shape_init` is called first to set up the foundation, followed by `rect_init` to define the specific shape behavior.

### Adapting Previous Patterns

The Family Pattern can wrap any of the previous patterns (Object, Opaque, Private), but they offer different trade-offs when used as a specific member:

#### 1. Object Pattern (e.g., Rectangle)

- **Implementation**: Embed the full `rectangle_t` struct directly.
- **Pros/Cons**: It is **simple** and efficient, but it exposes all internal fields of the specific shape to the user of the derived class.

#### 2. Opaque Pattern (e.g., Circle)

- **Implementation**: Embed the `hCircle` handle.
- **Pros/Cons**: It is **secure** (hides data), but awkward in this context. It requires managing the handle life-cycle separately, potentially involving extra memory allocations, which negates some benefits of the flat memory layout.

#### 3. Private Pattern (e.g., Triangle)

- **Implementation**: Embed the `triangle_t` struct (which contains the `_private` blob).
- **Pros/Cons**: This offers the **best balance**. It allows static allocation (like the Object pattern) ensuring a contiguous memory block, but effectively hides implementation details (like the Opaque pattern). It adapts perfectly to inheritance without the overhead of dynamic memory management.

The **Private Pattern** is often the preferred choice for the specific part of a derived class because it maintains encapsulation while remaining friendly to embedding and static allocation.

### Example Usage

This example demonstrates **Polymorphism**. We create different shapes (`Rectangle`, `Circle`, `Triangle`), initialize them with their specific *and* base configurations, and then treat them indistinctly as `shape_t*` pointers.

{{ file "companion_code/ch3_patterns/tests/srctest/familyTests.cpp" type="test" name="FamilyPattern,PolymorphismExample" }}

By iterating over the `shapes` array, we can access the common `type` and `color` fields without knowing the specific implementation of each object.
