## Simple Callback Pattern

### Pattern Description

The Simple Callback Pattern is the most basic form of decoupling between a "producer" module and a "consumer." Instead of calling a specific function by name (which would require the producer to `#include` the consumer's header), the module stores a **function pointer** and calls it when an event occurs. The producer never needs to know *who* is listening — only *how* to call them.

This is a **1:1, runtime-configurable** notification mechanism. The callback can be set at initialization time (as a field in the configuration structure) or swapped later through a dedicated setter function. Either way, there is exactly one listener at any given time — if the setter is called again, the previous callback is silently replaced ("last setter wins").

#### **Key Use Cases**

- **Continuous monitoring events**: A module reports every change as it happens (e.g., position updates during movement, ADC sample-ready signals, sensor readings at each scan cycle).
- **Single-listener notifications**: When only one consumer needs the event — for example, a logging module that tracks every position change.
- **Configuration-time binding**: The callback is established at initialization, not at compile time, allowing the same module to serve different consumers in different builds.

#### **Benefits**

- **Decoupling**: The module is agnostic to who listens. It only knows the callback signature.
- **Simplicity**: No linked lists, no registration arrays — just a function pointer and an optional context. Can be passed as a config argument at init or set later with a dedicated setter function.
- **Zero overhead when unused**: If the callback is `NULL`, the module simply skips the notification — just a pointer check.
- **Runtime flexibility**: The listener can be enabled, disabled, or swapped at runtime without recompilation.

#### **Drawbacks**

- **Single listener only**: If two consumers need the same event, this pattern does not scale — you would need the Observer Pattern (section 3.10).
- **Ownership clarity**: The module stores the function pointer and context internally, but the user/listener owns the actual function being called. This split is straightforward but worth making explicit.
- **Last-setter-wins**: If the setter is called multiple times, the last callback set is the one that gets called — previous listeners are silently replaced. This is simple but can surprise developers who expect additive behavior (for that, see the Observer Pattern in 3.10).

### Implementation

The implementation lives in the same `canvas` module used throughout this chapter. The position listener demonstrates the Simple Callback pattern: a single function pointer that fires on every position change during shape movement.

#### Header File

{{ file "companion_code/ch3_patterns/include/canvas.h" type="whole" }}

The key elements for this pattern are:

1. **The callback signature** (`canvas_positionListener_t`): a `typedef` defining what the listener function looks like — it receives the shape, its new coordinates, and a `void *context`.
2. **The configuration structure** (`canvas_config_t`): the callback and its context are fields in the config, establishing the listener at initialization time.
3. **The runtime API** (`canvas_setPositionChangeCallback`, `canvas_enablePositionListener`, `canvas_disablePositionListener`): allows swapping or toggling the listener after initialization.

**The `void *context` pattern** deserves special attention. By passing an opaque `void *` alongside the callback, the consumer can access its own state without relying on global variables. This is a recurring C idiom — every OS callback API uses it (pthreads, FreeRTOS timer callbacks, interrupt handler registration). The module never dereferences this pointer; it simply passes it back to the callback.

#### Source File

The listener is invoked inside `update_position()`, which is called by `canvas_task()` on every tick. When a shape moves, the function checks three conditions before firing: the shape actually moved, the listener is enabled, and the callback pointer is not `NULL`.

{{ file "companion_code/ch3_patterns/src/canvas.c" type="function" name="update_position" }}

Notice the guard pattern: `if (moved && positionListenerEnabled && positionListener != NULL)`. This three-way check is the standard idiom for optional callbacks — it ensures zero cost when the feature is unused while remaining safe when the callback is set but temporarily disabled.

### Example Usage

The following example demonstrates the position listener in action. We set it at initialization, move two shapes, and observe that the callback fires on **every position change** — not just when the movement completes.

{{ file "companion_code/ch3_patterns/tests/srctest/canvasTests.cpp" type="test" name="CanvasPosition,usage_example" }}

#### Walkthrough

1. **Initialization**: The listener is set through `canvas_config_t` at init time — this is the "config-time binding" approach.
2. **Movement**: Two shapes are moved simultaneously. The listener fires on every step for every shape.
3. **Disable**: Mid-movement, the listener is disabled. The shape continues to move, but no callbacks fire.
4. **Swap and re-enable**: The callback is replaced with a new context via `canvas_setPositionChangeCallback` and re-enabled. From this point, the new context is passed to the callback.

### Summary

The Simple Callback pattern transforms hard-coded function calls into runtime-configurable notifications. One producer, one consumer, zero allocation. It is the right choice when only a single listener is needed and the relationship is straightforward. When multiple independent consumers need the same event, the Observer Pattern (section 3.10) provides the next step.
