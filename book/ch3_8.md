## Singleton Pattern (Static Module)

### Pattern Description

The Singleton Pattern in this context is best described as a **Static Module**. While previous patterns focused on creating objects (where you might have many instances of a `Rectangle`), this pattern is designed for non-object-oriented modules that must hold a unique system state.

Instead of having loose global variables scattered across a file (e.g., `int g_count;`, `bool g_is_init;`), this pattern groups all related state into structured "singleton contexts." This ensures that there is exactly **one instance** of the state, clearly organized into structures.

#### **Key Use Cases**

- **Static Modules**: Any module that is not an "object" but holds internal state (counters, buffers, flags).
- **System Services**: Hardware registries, communication drivers, or event managers.
- **Tasks-Based Modules**: Modules that have a periodic `Tasks()` function to process data.

#### **Benefits**

- **Grouped State**: By collecting all variables into a single struct, the module's "context" becomes an explicit entity rather than a collection of loose variables.
- **Context Communication**: It becomes significantly easier to pass the entire module state to other sub-systems or to inspection tools (like a debugger or a logging system) because it is a single pointer.
- **Testability**: Unit tests can easily inspect or reset the entire state of the module by interacting with the singleton structure, rather than hunting down individual global variables.
- **Read-Only Access**: The pattern allows providing a high-performance "public view" of the state (read-only) while keeping the actual modification logic internal.

#### **Drawbacks**

- **Testing Isolation**: As with all static state, tests must explicitly reset the singleton between runs to prevent cross-test pollution.
- **Concurrency**: Grouping variables doesn't automatically solve race conditions; shared access still requires careful management.

### Implementation

The core idea is to split the singleton state into two structures: **Public** and **Private**.

#### Header File

The header file defines the **Public** state structure. This is the "read-only view" that the rest of the system can see.

**Key Design Highlight: The Read-Only View**
The initialization function returns `const shape_registry_data_t *`. This allows any other module to read the registry's state (like the count or the current "biggest area" shape) with **zero overhead**â€”it's just a pointer dereference. However, the `const` qualifier strictly prevents external modules from corrupting this state. Modifications are restricted to the module's specific API functions.

{{ file "companion_code/ch3_patterns/include/shape_registry.h" type="region" name="registry_header" }}

#### Source File

The source file defines the **Private** state structure and the logic to manipulate both.

**Key Design Highlight: Public vs. Private Contexts**
We maintain two static instances:
1.  `g_registry_data`: The public data exposed to the world.
2.  `priv_registry_data`: Internal housekeeping variables (flags, caches) that no one else needs to see.

**Key Design Highlight: The Tasks Pattern**
This pattern is ideal for modules with a `Tasks()` function. Operations like `Register` are designed to be fast (O(1)) and simply flag that a change occurred. The `shapeRegistry_Tasks` function then processes these changes (like finding the biggest shape) at a defined point in the execution cycle.

{{ file "companion_code/ch3_patterns/src/shape_registry.c" type="region" name="registry_impl" }}

### Example Usage

The following example demonstrates how grouping the state simplifies usage and verification. We can initialize the system, perform operations, and then immediately verify the complex internal state by reading the singleton pointer.

{{ file "companion_code/ch3_patterns/tests/srctest/singletonTests.cpp" type="test" name="SingletonPattern,usage_example" }}

#### Walkthrough

1.  **Initialization**: `shapeRegistry_Init()` resets the static structures and returns the handle.
2.  **Registration**: We register shapes. The module internally updates the public `count` and the private `dirty` flags.
3.  **Processing**: We call `shapeRegistry_Tasks()`. The module sees the flag and re-calculates the statistics.
4.  **Verification**: Because we have the public singleton pointer `registry`, checking the result is trivial: `registry->biggestArea`. We don't need to call a specific getter function; we just read the state we need.

### Summary

The Singleton (Static Module) pattern transforms "global variables" into "System State." By grouping variables into Public and Private structures, we create modules that are easier to understand, safer to access (via `const` pointers), and significantly easier to debug and test. It is the standard approach for any C module that manages a unique resource or service.
