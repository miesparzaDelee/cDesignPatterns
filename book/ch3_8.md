# Chapter 3.8: Singleton Pattern

## Pattern Description

The Singleton Pattern ensures that a class has only one instance and provides a global point of access to it. This is particularly useful in embedded systems where you need centralized management of a resource or state, such as a configuration manager, hardware abstraction layer, or a registry of active objects.

While often criticized for introducing "global state" that can make testing difficult, the Singleton pattern has legitimate uses in resource-constrained embedded environments where you need to guarantee single-point access and ensure resources aren't duplicated.

#### **Key Use Cases**

- **Configuration Management**: Global system settings that need to be accessed from multiple modules
- **Hardware Resource Management**: Ensuring only one driver instance controls a specific peripheral
- **Registry/Database of Active Objects**: Central catalog of all instances in the system
- **Logging/Error Reporting**: Centralized logging facility where multiple modules report events
- **State Machines**: Global state tracking for the entire application

#### **Benefits**

- **Resource Control**: Guarantees only one instance exists, preventing duplication of expensive resources
- **Global Access**: Provides a well-known access point for modules that need the service
- **Lazy Initialization**: Can defer initialization until first use (useful for complex embedded boot sequences)
- **Single Responsibility**: Encapsulates a specific global responsibility into one module

#### **Drawbacks**

- **Testing Complexity**: Singletons introduce global state that can make unit tests less isolated
- **Hidden Dependencies**: Modules using the singleton have implicit dependencies that aren't visible in function signatures
- **Concurrency Issues**: If not thread-safe, singletons can cause race conditions in multi-threaded environments
- **Inflexibility**: The "only one instance" restriction can limit future design changes

The Singleton Pattern is best used when you're certain you need exactly one instance of a class. For some use cases, alternatives like dependency injection (passing the instance through function arguments) may be more appropriate.

## Implementation

### Design Considerations

For the Singleton pattern to work cleanly in C, we need:

1. **A static/global instance**: The singleton instance that persists for the program's lifetime
2. **Thread-safe initialization**: Ensuring the instance is created once, even if multiple threads attempt initialization
3. **Public access method**: A function that returns the singleton instance (creating it if necessary)
4. **Opaque memory management**: Following the established patterns, we pass a memory block to the initialization function

### Header File

The header file defines the singleton interface. Note that we expose the memory size constant so users can allocate memory correctly:

{{ file "companion_code/ch3_patterns/include/shape_registry.h" type="whole" }}

Key design elements:
- `SHAPE_REGISTRY_SIZE` constant allows users to allocate the correct amount of memory
- `shape_registry_memory_t` opaque memory block for implementation hiding
- `hShapeRegistry_t` handle type (pointer to incomplete `struct shape_registry`)
- `shape_registry_config_t` configuration structure passed at initialization

### Source File

The implementation maintains a static global pointer to the singleton instance and creates it on first access:

{{ file "companion_code/ch3_patterns/src/shape_registry.c" type="whole" }}

Key implementation details:

1. **Static global pointer**: `g_registry` holds the singleton instance
2. **On-demand creation**: First call to `shapeRegistry_GetInstance()` creates the instance
3. **Memory reuse**: Casts the provided memory block to `struct shape_registry`
4. **Simple array storage**: Stores shape pointers in a fixed-size array
5. **Count tracking**: Maintains current item count for boundary checking

Note: This implementation uses a simple array with linear search for removal. More sophisticated data structures (like a hash table) could be used for larger registries.

### Initialization Pattern

Users initialize the singleton by providing a memory block and optional configuration:

```c
/* Allocate singleton storage */
shape_registry_memory_t registry_mem;

/* Optional: configuration structure */
shape_registry_config_t config = {
    .max_capacity = 16,  // Limit registry size
};

/* Get/create the singleton instance */
hShapeRegistry_t registry = shapeRegistry_GetInstance(&registry_mem, &config);
```

The first call creates the singleton; subsequent calls return the same instance:

```c
/* Second call returns same instance */
hShapeRegistry_t registry2 = shapeRegistry_GetInstance(&different_mem, NULL);
/* registry == registry2 */
```

This ensures exactly one instance exists throughout the application, regardless of how many modules call `shapeRegistry_GetInstance()`.

## Example Usage

Here's a realistic example showing how the Shape Registry can be used to track all shapes in a drawing application:

{{ file "companion_code/ch3_patterns/tests/srctest/registryTests.cpp" type="test" name="ShapeRegistry_SingletonPattern,singleton_returns_non_null" }}

The test demonstrates multiple aspects of the Singleton pattern:

1. **Singleton creation**: First call creates and initializes the instance
2. **Global access**: Multiple calls to `GetInstance()` return the same pointer
3. **On-demand initialization**: The singleton is created when first requested
4. **State management**: The registry tracks registered shapes across function calls

A more complete example might look like this in a real application:

```c
/* Initialize the registry (in main or startup) */
shape_registry_memory_t registry_mem;
shapeRegistry_GetInstance(&registry_mem, NULL);

/* Create shapes as normal */
rectangle_t rect1, rect2;
rect_config_t rect_cfg = { .width = 10, .height = 5 };
rect_init(&rect1, &rect_cfg);
rect_init(&rect2, &rect_cfg);

/* Register them in the global registry */
hShapeRegistry_t registry = shapeRegistry_GetInstance(NULL, NULL);
shapeRegistry_Register(registry, (shape_t*)&rect1.base);
shapeRegistry_Register(registry, (shape_t*)&rect2.base);

/* Later: iterate and draw all registered shapes */
uint32_t count = shapeRegistry_GetCount(registry);
for (uint32_t i = 0; i < count; i++) {
    shape_t *shape = shapeRegistry_GetAtIndex(registry, i);
    if (shape && shape->visible) {
        /* draw shape... */
    }
}
```

## Thread Safety Considerations

In embedded systems with multiple threads or interrupts, the singleton initialization must be thread-safe to prevent race conditions where two threads might try to create the instance simultaneously.

The current implementation in this example uses a simple static pointer check, which works for single-threaded environments. For multi-threaded systems, you might need to add:

```c
hShapeRegistry_t shapeRegistry_GetInstance(shape_registry_memory_t *mem, 
                                          const shape_registry_config_t *config)
{
    /* Thread-safe double-checked locking */
    if (g_registry == NULL) {
        /* Acquire mutex/lock */
        if (g_registry == NULL) {
            g_registry = (struct shape_registry *)mem;
            /* ... initialize ... */
        }
        /* Release mutex/lock */
    }
    return g_registry;
}
```

Alternatively, a simpler approach for resource-constrained systems is to initialize the singleton during startup before threads are created, guaranteeing single-threaded initialization.

## Alternatives to Consider

Before deciding on a Singleton, consider these alternatives that might avoid some of the drawbacks:

### 1. Dependency Injection (Passing the Instance)

Instead of global access, pass the registry instance to functions that need it:

```c
/* In header: declare but don't enforce singleton */
hShapeRegistry_t shapeRegistry_Create(shape_registry_memory_t *mem, 
                                      const shape_registry_config_t *config);

/* In init code: create and distribute */
hShapeRegistry_t registry = shapeRegistry_Create(&mem, &config);
draw_module_Init(registry);     /* Pass to modules that need it */
input_module_Init(registry);
```

### 2. Static Instance with Extern Declaration

In one C file: `static struct shape_registry g_registry;`

In header: `extern struct shape_registry g_registry;`

This is simpler but less testable.

### 3. Service Locator Pattern

A registry of services where modules register themselves and look up dependencies, rather than hardcoding singletons.

## Choosing Singleton

Use the Singleton Pattern when:
- You need **exactly one** instance of a resource or service
- The service needs to be **globally accessible** from multiple modules
- **Resource constraints** make multiple instances impractical
- Initialization can be **deferred** until first use

Avoid Singleton when:
- It makes **testing difficult** (consider dependency injection instead)
- It creates **hidden dependencies** between modules
- You might need **multiple instances** in the future

## Summary

The Singleton Pattern provides a controlled way to manage global state and resources in embedded systems. The Shape Registry example demonstrates a practical use case where tracking all objects in a system requires a single, authoritative source of truth.

When implementing Singleton in C for embedded systems:
- Use **opaque memory allocation** for encapsulation
- Provide **configuration** at initialization for flexibility
- Consider **thread safety** for multi-threaded environments
- Keep the interface **minimal and focused** on a single responsibility

The next pattern builds on this by expanding from single notifications to multiple observers.
