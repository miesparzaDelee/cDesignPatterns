## Factory Pattern

### Overview

Centralizes object creation. The factory decides which concrete shape to build and returns a unified polymorphic type (`shape_api_t*`). It hides the complexity of building the shape, initializing it, and assigning a vtable.

### Implementation

#### Factory Function

```c
shape_api_t* shapeFactory_create(shape_type_t type, void* config);
```

#### Internal Process

1. Allocate or use static memory for `api_rectangle_t` / `api_circle_t` / `api_triangle_t`
2. Initialize the underlying `shape_rectangle` / `shape_circle` / `shape_triangle`
3. Attach the correct vtable
4. Return `(shape_api_t*)`

### Important Notes

- Factory works best at the **VTABLE LAYER**, not the inheritance layer
- This allows the user to call `get_area`/`draw` generically regardless of shape type
- Cleanly hides creation logic and promotes modularity

### Discriminated Union Pattern

The factory uses a **discriminated union** to accept different configuration types through a single parameter:

```c
typedef struct {
    shape_type_t type;              // Discriminator: tells which union member is active
    union {
        rect_config_t rect;         // Rectangle configuration
        circle_config_t circle;     // Circle configuration
        triangle_config_t triangle; // Triangle configuration
    } config;
} factory_config_t;
```

**How it works:**

1. The `type` field acts as a **discriminator** - it tells the factory which union member is valid
2. Only **one** union member is active at any time (memory is shared)
3. The user sets `type` first, then fills in the corresponding config member

```c
factory_config_t conf = {0};

// Creating a circle
conf.type = SHAPE_TYPE_CIRCLE;
conf.config.circle.radius = 10;

// Creating a rectangle
conf.type = SHAPE_TYPE_RECTANGLE;
conf.config.rect.width = 20;
conf.config.rect.height = 15;
```

This pattern eliminates the need for multiple factory functions and keeps the API clean while maintaining type safety at compile time.
