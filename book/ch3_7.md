## Factory Pattern

### Pattern Description

The Factory Pattern centralizes object creation logic, delegating instantiation decisions to a dedicated function rather than exposing constructors directly. The caller requests an object through a generic interface, and the factory determines the concrete type to create based on configuration or parameters.

This approach decouples the **what** (what object is needed) from the **how** (how to create it). The caller doesn't need to know which specific type will be instantiated, only what kind of behavior it should provide. This is particularly valuable when object creation involves complex logic, conditional decisions, or when you want to hide implementation details from users.

#### **Key Use Cases**

- **Plugin Systems**: Loading different implementations based on configuration files or discovery
- **Hardware Abstraction**: Creating device drivers from common device descriptors
- **Cross-Platform Code**: Instantiating platform-specific objects based on runtime detection
- **Object Pools**: Managing pre-allocated objects that need specialized initialization

#### **Benefits**

- **Decoupling**: Callers depend only on the factory interface, not concrete types
- **Single Responsibility**: All creation logic lives in one place, making it easier to modify and maintain
- **Configurability**: New types can be added without changing existing caller code
- **Testability**: Easy to substitute factories for testing with mock objects

#### **Drawbacks**

- **Indirection**: Extra function call adds minimal overhead
- **Complexity**: More moving parts to understand and debug
- **Type Safety**: Implementation techniques like unions or void pointers can bypass compile-time checks

### Implementation

The factory receives a pre-allocated polymorphic type and a configuration structure. It inspects the configuration to determine the concrete type, casts the memory appropriately, and initializes it.

#### **Header Files**

{{ file "companion_code/ch3_patterns/include/factory_shape.h" type="whole" }}

The factory uses a discriminated union technique in `factory_config_t` to accept different configuration types through a single parameter.  This approach saves memory by having all variant types share the same memory regionâ€”the largest variant determines the total size. See **Convention CS-07** in Chapter 2 for details on this technique and its benefits for memory-constrained systems.

#### **Source Files**

The factory function switches on the type field and dispatches to the appropriate initialization function:

{{ file "companion_code/ch3_patterns/src/factory_shape.c" type="whole" }}

### Example Usage

This example demonstrates creating different shapes through a uniform factory interface. The caller doesn't need to know which concrete type will be created - it only specifies the desired type through configuration and receives a generic `api_shape_t*` back.

{{ file "companion_code/ch3_patterns/tests/srctest/factoryTests.cpp" type="test" name="FactoryPattern,Polymorphism" }}

The factory works best at the **VTABLE LAYER**, not the inheritance layer. This allows the user to call `shape_get_area` or `shape_draw` generically regardless of the actual shape type, cleanly hiding initialization logic and promoting modularity.
