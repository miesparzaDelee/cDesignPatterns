## Object Pattern

### Pattern Description

The Object Pattern encapsulates state and behavior in a modular, reusable structure, allowing for multiple independent instances of the same functionality.
Its main purpose is to create self-contained objects with well-defined APIs that operate independently of each other.
The best usage cases for this pattern include the following:

- Managing multiple instances of a resource or component (e.g., multiple sensors, devices, or configurations).  
- Abstracting state and behavior into a reusable structure.  

This pattern uses a structure definition, such as `object_t` (see recommended practice for naming structs), to encapsulate the internal state of an instance.
Object structs can be created statically or dynamically, depending on the needs.
It is recommended to leave the responsibility of object allocation to the module user (upstream code).  

Functions operate on instances passed as pointers, which are usually named `self` within an API (see recommended practice for naming objects).
The object state and behavior are encapsulated in its definition, and no state is retained within any of its handling functions.
All struct members must be **read-only** and can be accessed directly but should only be modified through API functions.
Each object must include an initialization function (`Init`) that sets the initial state. This function may optionally accept a configuration parameter to allow user-specific configuration.  

#### Benefits

- Allows for multiple independent instances of a module.  
- Promotes modularity by isolating state and logic.  
- Improves code readability and maintainability.  

#### Drawbacks

- Requires explicit memory management by the module user.  
- Slightly increases function call complexity due to instance-specific pointers.
- Exposes the object state and internal behavior to the user.  

### Implementation  

#### Header File

The header file defines the object’s structure and declares the APIs that users can call to interact with the object.
Let’s use a simple geometric shape, a **Rectangle**, as our example.

{{ file "companion_code/ch3_patterns/include/rectangle.h" type="typedef" name="rectangle_t" }}

This structure is the core of the Object Pattern. It encapsulates the properties of a specific rectangle: its `width` and `height`.
Notice the `const` qualifier on the `area` field. This makes it **read-only** from the user's perspective—they can access `rect.area` directly, but cannot modify it.
This is useful for dependent state that should only be updated internally by the module's API functions.
The implementation can still update this field using pointer casting (e.g., `*(uint32_t *)&self->area = ...`), ensuring the area stays synchronized with width and height changes.

Next, we expose the functions that operate on instances of `rectangle_t`:

{{ file "companion_code/ch3_patterns/include/rectangle.h" type="function" name="rect_init" }}

{{ file "companion_code/ch3_patterns/include/rectangle.h" type="function" name="rect_get_area" }}

The `rect_init` function initializes the object with specific dimensions.
The `self` parameter represents the specific object instance being operated on. This is critical: by passing the pointer, we tell the function *which* rectangle's area to calculate.

#### Source File

The source file contains the implementation. Notice how the logic relies entirely on the data within the `self` pointer.

{{ file "companion_code/ch3_patterns/src/rectangle.c" type="function" name="rect_init" }}

{{ file "companion_code/ch3_patterns/src/rectangle.c" type="function" name="rect_get_area" }}

Because the functions use `self->width` and `self->height` rather than global variables, we can create as many independent rectangles as we need.

### Example Usage

Below is an actual unit test demonstrating how to use the rectangle module with multiple independent instances:

{{ file "companion_code/ch3_patterns/tests/srctest/rectagleTests.cpp" type="test" name="Rectangle_ObjectPattern,demonstrates_MultipleIndependentInstances" }}

In this test, `small_rect` and `big_rect` are completely independent. Each has its own state, and modifying one does not affect the other.
This demonstrates the power of the Object Pattern: **Encapsulation of state allows for multiple instances of the same logic.**
  