## Object Pattern

### Pattern Description

The Object Pattern encapsulates state and behavior in a modular, reusable structure, allowing for multiple independent instances of the same functionality.
Its main purpose is to create self-contained objects with well-defined APIs that operate independently of each other.
The best usage cases for this pattern include the following:

- Managing multiple instances of a resource or component (e.g., multiple sensors, devices, or configurations).  
- Abstracting state and behavior into a reusable structure.  

This pattern uses a structure definition, such as `object_t` (see recommended practice for naming structs), to encapsulate the internal state of an instance.
Object structs can be created statically or dynamically, depending on the needs.
It is recommended to leave the responsibility of object allocation to the module user (upstream code).  

Functions operate on instances passed as pointers, which are usually named `self` within an API (see recommended practice for naming objects).
The object state and behavior are encapsulated in its definition, and no state is retained within any of its handling functions.
All struct members must be **read-only** and can be accessed directly but should only be modified through API functions.
Each object must include an initialization function (`Init`) that sets the initial state. This function may optionally accept a configuration parameter to allow user-specific configuration.  

#### Benefits

- Allows for multiple independent instances of a module.  
- Promotes modularity by isolating state and logic.  
- Improves code readability and maintainability.  

#### Drawbacks

- Requires explicit memory management by the module user.  
- Slightly increases function call complexity due to instance-specific pointers.
- Exposes the object state and internal behavior to the user.  

### **Implementation**  

#### **Header File**  

The header file defines the object’s structure and declares the APIs that users can call to interact with the object.  
Let’s start by looking at the object structure:  

{{ file "src/patterns/include/objectPattern.h" type="typedef" name="object_t" }}

This structure is the core of the Object Pattern, as it encapsulates the state of an individual *instance*.  

For example, the field *`variable`* serves as a general-purpose attribute that holds instance-specific data, such as a sensor reading or a configuration setting.  
Similarly, the *`flags`* field can represent the operational state of the object, allowing efficient state tracking.  

Next, we expose the functions that operate on instances of `object_t`:  

{{ file "src/patterns/include/objectPattern.h" type="function" name="op_Init" }}

{{ file "src/patterns/include/objectPattern.h" type="function" name="op_DeInit" }}

As their names indicate, these functions handle the initialization and de-initialization of the object.  
The `self` parameter represents the specific object instance being operated on, ensuring that the API can manage multiple instances independently.  
This approach guarantees that state management remains instance-specific.  

Initialization relies on a dedicated configuration structure, which defines all user/application parameters:  

{{ file "src/patterns/include/objectPattern.h" type="typedef" name="object_config_t" }}

#### **Source File**  

The source file contains the implementation of the APIs declared in the header.  
The implementation of the initialization function `op_Init` is shown below:  

{{ file "src/patterns/objectPattern.c" type="function" name="op_Init" }}

{{ file "src/patterns/objectPattern.c" type="function" name="op_DeInit" }}

Notice how the specific configuration and further operations are scoped to the specific instance.  
Since the function operates on the address of any `object_t` variable passed, all instance-related data remains encapsulated within the object.  
Functions that manipulate instances rely entirely on the object’s internal state and do not retain external data.  

##### **Implementation Key Highlights**  

- **Instance-Specific Operations**: Each function operates only on the instance provided as `self`, ensuring encapsulation and preventing unintended side effects.  
- **Explicit State Management**: The object's state is managed through its internal variables, with no hidden or persistent data in the function implementation.  
- **Safe Initialization**: The `op_Init` function starts by calling `op_Deinit`, ensuring that the object is in a clean state before applying any configuration.

### **Example Usage**  

Below is an example of how to use the module:  

```c
#include "objectPattern.h"

int main() {
    // Declare and allocate an object instance
    object_t myObject;
    object_config_t config = {
        .parameter1 = 5,  // Configuration value for parameter1
        .parameter2 = 0,  // Configuration value for parameter2
    };

    // Initialize the object with configuration
    op_Init(&myObject, &config);

    // Access the object fields
    if (myObject.flags & OBJECT_PATTERN_FLAG_1) {
        // Perform specific action when FLAG_1 is set
    }

    // De-initialize the object when done
    op_DeInit(&myObject);

    return 0;
}
```
In this example, an instance of `object_t` (`myObject`) is declared and initialized using the `op_Init` function.  
A configuration structure (`config`) is defined to specify the initialization parameters.  

- `parameter1` is set to 5, which activates logic enabling `OBJECT_PATTERN_FLAG_1`.  
- `parameter2` is set to 0, meaning no additional flags are enabled.  

During initialization, the object’s state is set based on the provided configuration.  
The example demonstrates how to access the `flags` field to determine the object's operational state.  
If `OBJECT_PATTERN_FLAG_1` is set, an action is performed accordingly.  
This highlights how an object’s state can guide application logic in a structured and modular manner.  

Finally, `op_DeInit` is called to reset `myObject`.  
This step ensures the object is properly cleaned up, preventing unintended residual states and preparing it for reuse or safe disposal.