## Observer Pattern (1:N Notifications)

### Pattern Description

The Simple Callback (section 3.9) works when exactly one consumer cares about an event. But what happens when **multiple independent modules** need to react to the same event? A UI module, a logging module, and a state machine all want to know when a shape finishes moving — and they should be able to subscribe independently without knowing about each other.

The Observer Pattern answers this with **1:N notifications**: multiple listeners register independently, and all are notified when the event occurs. The key design challenge in C is storing N callbacks without dynamic memory allocation. The solution used here is the **opaque observer node** — the user allocates the storage, the module manages the linked list.

This is a common pattern in embedded systems: interrupt handler dispatch tables, event bus systems, and publish-subscribe mechanisms in RTOS middleware all follow this model.

#### **Key Use Cases**

- **Multiple independent consumers**: A "movement complete" event interests the UI module, a logging module, *and* a state machine — all simultaneously.
- **Dynamic subscription**: Modules can register and deregister observers at runtime (e.g., a debug logger that only subscribes during development).
- **Decoupled extensions**: New features can subscribe to existing events without modifying the producing module.

#### **Benefits**

- **Unlimited listeners**: Any number of observers can register, limited only by user-allocated nodes.
- **User-managed allocation**: The module never calls `malloc` — the user provides observer nodes, fitting embedded constraints perfectly.
- **Zero coupling between observers**: Each observer is independent; adding one does not affect the others.
- **Dynamic registration**: Observers can come and go at runtime via register/deregister, enabling flexible system composition.

#### **Drawbacks**

- **Iteration cost**: The module must walk the linked list on every event, adding O(N) overhead per notification.
- **Order dependency**: Observers are notified in registration order (reversed, since new nodes are prepended), which can introduce subtle bugs if consumers have interdependencies.
- **More complex API surface**: Register, deregister, and the opaque node type add API complexity compared to a simple callback setter.
- **Lifetime management**: If an observer node goes out of scope while still registered, the linked list corrupts silently — there is no runtime safety net.

### Implementation

The observer pattern extends the same `canvas` module from section 3.9. While the position listener (3.9) is a 1:1 callback for every position change, the move observer is a 1:N notification that fires **once** when a shape finishes its movement — and all registered observers receive it.

#### Header File

The header exposes two key elements for this pattern:

{{ file "companion_code/ch3_patterns/include/canvas.h" type="typedef" name="canvas_move_observer_t" }}

**The opaque node technique.** The `canvas_move_observer_t` is a struct sized with `_reserved[CANVAS_OBSERVER_SIZE]`. The user allocates it (on the stack, as a static variable, or embedded in their own struct), but cannot see or touch its internals. Inside the module, it is cast to an internal struct with `next`, `callback`, and `context` fields.

This directly applies the Opaque Pattern from section 3.3: the same principle of hiding internals, but here the hidden data is a **linked list node** instead of object state.

The registration API is straightforward:

{{ file "companion_code/ch3_patterns/include/canvas.h" type="function" name="canvas_register_move_observer" }}

{{ file "companion_code/ch3_patterns/include/canvas.h" type="function" name="canvas_deregister_move_observer" }}

#### Source File

Inside the module, the opaque node is cast to its internal representation — a standard singly-linked list node:

{{ file "companion_code/ch3_patterns/src/canvas.c" type="typedef" name="canvas_move_observer_internal_t" }}

**Registration** casts the opaque node, fills its fields, and prepends it to the linked list. This is O(1):

{{ file "companion_code/ch3_patterns/src/canvas.c" type="function" name="canvas_register_move_observer" }}

**Deregistration** walks the list to find and unlink the node. Note the double-pointer technique (`**curr`): it eliminates the need for a special case when removing the head node, because `curr` always points to the `next` pointer that needs to be updated — whether it is the head pointer itself or a node's `next` field.

{{ file "companion_code/ch3_patterns/src/canvas.c" type="function" name="canvas_deregister_move_observer" }}

**Notification** happens inside `canvas_task()`. When a shape finishes its movement, the module walks the entire observer list and calls each registered callback:

{{ file "companion_code/ch3_patterns/src/canvas.c" type="function" name="canvas_task" }}

### Example Usage

The following example demonstrates the full observer lifecycle: registering multiple observers, triggering events, and verifying that all observers receive their notifications.

{{ file "companion_code/ch3_patterns/tests/srctest/canvasTests.cpp" type="test" name="CanvasMove,usage_example" }}

#### Walkthrough

1. **Register first observer**: `obs1` is registered with `appState1` as its context. At this point, only one observer is in the list.
2. **Create and move shapes**: Three rectangles are added and given movement targets.
3. **Register second observer mid-operation**: `obs2` is added with a different context (`appState2`). This demonstrates dynamic subscription — new observers can join at any time.
4. **Main loop**: `canvas_task()` is called repeatedly. As each shape finishes moving, **both** observers are notified — producing 6 total callbacks (3 shapes × 2 observers).
5. **Verification**: All shapes have arrived at their targets, and the callback count confirms that every observer received every event.

### Comparison with 3.9

| Aspect | 3.9 Simple Callback | 3.10 Observer |
|--------|---------------------|---------------|
| Listeners | 1 | N |
| Storage | Module (function pointer field) | User (opaque nodes) |
| Registration | Set at init or via setter | Register/deregister API |
| Allocation | None | User allocates observer nodes |
| Notification cost | O(1) | O(N) |
| Use case | Single-consumer monitoring | Multi-consumer event dispatch |

### Summary

The Observer Pattern scales notifications from 1 to N without dynamic memory, using the opaque node technique to keep the linked list internals hidden from the user. The user allocates the observer struct, the module manages the links. This clean separation of concerns — **allocation by the user, management by the module** — is what makes the pattern practical for embedded systems where `malloc` is not an option.

The next section (3.11) takes this idea further: instead of the module defining the observer struct, the user embeds a small **intrusive node** directly into their own data structure, enabling even more flexibility.
