## Opaque Pattern

### **Pattern Description**

The Opaque Pattern hides the implementation details of an object from its users by exposing only an abstract handle, which is denoted by an `h` prefix (e.g., `hCircle_t`).
This approach separates the interface from the implementation, promoting encapsulation and modularity.

The primary purpose of this pattern is to safeguard the internal state and behavior of an object, ensuring that users interact only through a well-defined API.
By preventing direct access to the object's internal structure, the pattern enhances stability and reduces the risk of accidental misuse.  

#### **Key Use Cases**

- Protecting sensitive or complex internal states from being modified directly.  
- Abstracting implementation details, allowing internal changes without affecting the API.  
- Managing dependent state automatically (e.g., updating area when radius changes).

The Opaque Pattern uses an abstract handle (e.g., `hCircle_t`) to represent the object.
This handle is a pointer typedef (per convention NC-04). **Handles** with the `h` prefix can be used for both visible and opaque structs, but are particularly powerful for opaque types where the struct definition is hidden.

The handle struct is **declared** in the header file but **defined** only in the source file, ensuring the object's internal details remain hidden from external modules.

#### **Benefits**

- **Encapsulation**: Ensures that object internals are completely hidden from the user, improving modularity and maintainability.  
- **Flexibility**: Allows internal implementation to change without breaking external code, enabling easier updates and refactoring.  
- **Simplified Interface**: Exposes only the methods and data necessary for interacting with the object, reducing complexity for users.

### **Drawbacks**

- **Memory Management Complexity**: Requires users to explicitly state the internals size of the object.  
- **Performance Overhead**: Adds a slight runtime cost due to pointer dereferencing and the abstraction layer in function calls.

### **Implementation**

#### **Header File**

Let's use another simple geometric shape, a **Circle**, as our example.

Unlike the **Object Pattern** where the struct is fully visible, the Opaque Pattern hides all internal details.
This is useful when you want to prevent users from accessing or depending on the struct's internal fields, giving you complete freedom to change the implementation without breaking external code.

The header file exposes only what's necessary: a memory size constant and an opaque handle.

{{ file "companion_code/ch3_patterns/include/circle.h" type="define" name="CIRCLE_SIZE" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="circle_memory_t" }}

The `CIRCLE_SIZE` constant allows users to allocate the right amount of memory without knowing the internal structure.

{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="hCircle_t" }}

The handle `hCircle_t` is a pointer to an incomplete type. The compiler knows it exists but not what's inside.
Users can pass this handle around and use it with API functions, but they cannot access internal fields directly.

{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="circle_config_t" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_init" }}

The `circle_init` function takes raw memory and a configuration, then returns an opaque handle.

{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_updateRadius" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_getRadius" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_getArea" }}

All interaction happens through these API functions. The user cannot see that `area` is pre-calculated or how `radius` is stored.

#### **Source File**

The actual structure is defined privately in the source file, completely hidden from users.

{{ file "companion_code/ch3_patterns/src/circle.c" type="struct" name="circle" }}

{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_init" }}

The `circle_init` function casts the raw memory to `struct circle *`, initializes both `radius` and `area`, and returns the opaque handle.

{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_updateRadius" }}
{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_getRadius" }}
{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_getArea" }}

Notice how `circle_updateRadius` automatically recalculates the area. The module maintains internal consistency without user intervention.

### **Example Usage**

Below is an example demonstrating the use of a stack-allocated opaque circle object:

```c
#include "circle.h"
#include <stdio.h>

int main() {
    // 1. Allocate raw memory on the stack
    circle_memory_t circle_mem;
    
    // 2. Initialize the circle with radius = 10
    circle_config_t config = { .radius = 10 };
    hCircle_t myCircle = circle_init(&circle_mem, &config);
    
    if (myCircle == NULL) {
        printf("Error: Memory size mismatch!\n");
        return 1;
    }
    
    // 3. Use the circle through its opaque handle
    printf("Initial radius: %u\n", circle_getRadius(myCircle));
    printf("Initial area: %.2f\n", circle_getArea(myCircle));
    
    // 4. Update the radius - area is automatically recalculated
    circle_updateRadius(myCircle, 20);
    
    printf("Updated radius: %u\n", circle_getRadius(myCircle));
    printf("Updated area: %.2f\n", circle_getArea(myCircle));
    
    // No explicit cleanup needed - stack memory is automatically reclaimed
    return 0;
}
```

This example demonstrates how users interact with the opaque circle through its handle.

The user allocates raw memory (`circle_memory_t`), initializes it with `circle_init`, and receives an opaque handle.
All operations go through API functionsâ€”the user never sees or accesses the internal `radius` or `area` fields directly.
When `circle_updateRadius` is called, the area is automatically recalculated internally, ensuring consistency without user intervention.
