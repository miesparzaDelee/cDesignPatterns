## Opaque Pattern

### **Pattern Description**

The Opaque Pattern hides the implementation details of an object from its users by exposing only an abstract handle, which is denoted by an `h` prefix (e.g., `hCircle_t`).
This approach separates the interface from the implementation, promoting encapsulation and modularity.

The primary purpose of this pattern is to safeguard the internal state and behavior of an object, ensuring that users interact only through a well-defined API.
By preventing direct access to the object's internal structure, the pattern enhances stability and reduces the risk of accidental misuse.  

#### **Key Use Cases**

- Protecting sensitive or complex internal states from being modified directly.  
- Abstracting implementation details, allowing internal changes without affecting the API.  
- Managing dependent state automatically (e.g., updating area when radius changes).

The Opaque Pattern uses an abstract handle (e.g., `hCircle_t`) to represent the object.
This handle is a pointer typedef (per convention NC-04). **Handles** with the `h` prefix can be used for both visible and opaque structs, but are particularly powerful for opaque types where the struct definition is hidden.

The handle struct is **declared** in the header file but **defined** only in the source file, ensuring the object's internal details remain hidden from external modules.

#### **Benefits**

- **Encapsulation**: Ensures that object internals are completely hidden from the user, improving modularity and maintainability.  
- **Flexibility**: Allows internal implementation to change without breaking external code, enabling easier updates and refactoring.  
- **Simplified Interface**: Exposes only the methods and data necessary for interacting with the object, reducing complexity for users.

### **Drawbacks**

- **Memory Management Complexity**: Requires users to explicitly state the internals size of the object.  
- **Performance Overhead**: Adds a slight runtime cost due to pointer dereferencing and the abstraction layer in function calls.

### **Implementation**

#### **Header File**

Let's use another simple geometric shape, a **Circle**, as our example.

Unlike the **Object Pattern** where the struct is fully visible, the Opaque Pattern hides all internal details.
This is useful when you want to prevent users from accessing or depending on the struct's internal fields, giving you complete freedom to change the implementation without breaking external code.

The header file exposes only what's necessary: a memory size constant and an opaque handle.

{{ file "companion_code/ch3_patterns/include/circle.h" type="define" name="CIRCLE_SIZE" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="circle_memory_t" }}

The `CIRCLE_SIZE` constant allows users to allocate the right amount of memory without knowing the internal structure.

{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="hCircle_t" }}

The handle `hCircle_t` is a pointer to an incomplete type. The compiler knows it exists but not what's inside.
Users can pass this handle around and use it with API functions, but they cannot access internal fields directly.

{{ file "companion_code/ch3_patterns/include/circle.h" type="typedef" name="circle_config_t" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_init" }}

The `circle_init` function takes raw memory and a configuration, then returns an opaque handle.

{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_updateRadius" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_getRadius" }}
{{ file "companion_code/ch3_patterns/include/circle.h" type="function" name="circle_getArea" }}

All interaction happens through these API functions. The user cannot see that `area` is pre-calculated or how `radius` is stored.

#### **Source File**

The actual structure is defined privately in the source file, completely hidden from users.

{{ file "companion_code/ch3_patterns/src/circle.c" type="struct" name="circle" }}

{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_init" }}

The `circle_init` function casts the raw memory to `struct circle *`, initializes both `radius` and `area`, and returns the opaque handle.

{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_updateRadius" }}
{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_getRadius" }}
{{ file "companion_code/ch3_patterns/src/circle.c" type="function" name="circle_getArea" }}

Notice how `circle_updateRadius` automatically recalculates the area. The module maintains internal consistency without user intervention.

### **Example Usage**

Below is an actual unit test demonstrating how users interact with the opaque circle through its handle:

{{ file "companion_code/ch3_patterns/tests/srctest/circleTests.cpp" type="test" name="Circle_OpaquePattern,demonstrates_OpaqueHandleUsage" }}

The user allocates raw memory (`circle_memory_t`), initializes it with `circle_init`, and receives an opaque handle.
All operations go through API functionsâ€”the user never sees or accesses the internal `radius` or `area` fields directly.
When `circle_updateRadius` is called, the area is automatically recalculated internally, ensuring consistency without user intervention.

### **Mixing Approaches**

It's worth noting that you can combine elements from both patterns in a single module. For example, you might have:

- Some fields that are **public** (directly accessible)
- Some fields that are **read-only** (using `const`)
- Some fields that are **completely hidden** (opaque)

While this flexibility exists, mixing approaches can lead to inconsistent APIs and confusion about what users can and cannot access.
In practice, it's often clearer to choose one pattern and stick with it for a given module.
However, there are cases where you need fine-grained control over visibility and mutability without the overhead of full opacity.
The next pattern addresses this specific need.
