## Unit Testing and Verification

### Philosophy and Tooling

Verification is not an afterthought; it is an integral part of the development process. We advocate for **Test-Driven Development (TDD)**, where tests are written before the implementation. This ensures that the module's behavior is defined by its requirements and that the code is testable by design.

**CppUTest** is our recommended framework. It is a robust C/C++ unit testing framework that allows us to leverage the sophisticated features of C++ for creating powerful mocks and test harnesses while keeping the production code in pure C.

### Unit Testing Standards

<convention id="UT-01" title="Test Organization">
**Standard**: Each library must have a `test` folder. Inside, each module must have a corresponding test file (e.g., `test_module_name.cpp`) where all public API functions are tested.

**Rationale**: Keeps tests close to the code but separated from source, and ensures 1:1 mapping between modules and test suites.
</convention>

<convention id="UT-02" title="Test Folder Structure">
**Standard**: The `test` folder should follow a consistent internal structure:
- `runners/`: Contains the `main` entry point and build scripts.
- `src/`: Contains helper source files specific to testing (test doubles, fakes).
- `mocks/`: Contains generated mocks.
- `tests/`: Contains the actual test files (e.g., `ModuleTest.cpp`), mirroring the library's source structure.

**Rationale**: Separates test infrastructure from the test logic itself.
</convention>

<convention id="UT-03" title="Build and Test Automation Scripts">
**Standard**: Each library should include a `scripts/` folder at the module root containing:
- `run_tests.sh`: A shell script for building and running tests on Linux (the primary implementation)
- `invoke_wsl_tests.ps1`: A PowerShell wrapper that invokes the Linux script via WSL on Windows

**Detail**: Use **WSL as the common base environment** for both Windows and Linux development. The Windows PowerShell script should simply call the Linux script through WSL, rather than duplicating logic. This ensures a single source of truth for the build process. Scripts should handle path resolution, CPPUTEST_HOME detection, and build directory management automatically. See `companion_code/ch3_patterns/scripts/` for reference implementations.

**Rationale**: Having a single Linux-based script as the source of truth eliminates duplication and ensures identical behavior across Windows (via WSL), Linux, and CI environments. This approach was discovered through experienceâ€”it significantly reduces maintenance burden and prevents platform-specific bugs.
</convention>

<convention id="UT-04" title="Test Independence">
**Standard**: Each test must be self-contained and must not depend on the state or side effects of other tests. Usage of `setup` and `teardown` should ensure a clean state for every test.

**Rationale**: Prevents cascading failures and ensures that tests can be run in any order.
</convention>

<convention id="UT-05" title="Arrange, Act, Assert">
**Standard**: Test bodies should clearly follow the **AAA** pattern:
1. **Arrange**: Setup the state.
2. **Act**: Call the function under test.
3. **Assert**: Verify the results.

**Rationale**: Improves readability and standardizes test logic.
</convention>

<convention id="UT-06" title="Test Naming">
**Standard**: Test names should follow a pattern like `FunctionOrFeature_Condition_ExpectedResult` (e.g., `Init_NullPointer_ReturnsError`).

**Rationale**: Makes failures self-explanatory in the test report.
</convention>

<convention id="UT-07" title="Living Documentation">
**Standard**: Unit tests should serve as executable documentation. They should demonstrate the recommended usage, edge cases, and limits of the module.

**Rationale**: Unlike comments, compiled tests cannot drift out of sync with the code.
</convention>

<convention id="UT-08" title="Test Helpers">
**Standard**: Shared setup code and complex assertions should be abstracted into helper functions or "Test Objects". These should be located in the `test/src` directory and included as needed.

**Rationale**: Keep valid test functions focused on the AAA pattern and free of clutter.
</convention>

<convention id="UT-09" title="CppUTest Template">
**Standard**: Follow this standard template for new test files:
```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "module_under_test.h"
    // Mocks and other dependencies
}

TEST_GROUP(Module) {
    void setup() {
        module_init();
    }

    void teardown() {
        module_deinit();
    }
};

TEST(Module, Init_StateIsReset) {
    // Arrange
    // Act
    // Assert
}

```

**Rationale**: Provides a consistent starting point for all developers.
</convention>

## Debugging and Hardware Emulation

<draft>
In this
(Write your ideas for Debugging and Emulation here. How do we debug on host vs target? What is the 'Faking' strategy?)
</draft>
