## Unit Testing and Verification

### Philosophy and Tooling

Verification is not an afterthought; it is part of the design work. In an embedded codebase, the fastest development loop is the one that runs on your machine, without waiting for a board, a debugger, or a flaky test rig. Unit tests keep that loop tight while still building confidence that behavior stays correct over time.

We advocate for **Test-Driven Development (TDD)**, where tests are written before the implementation. The point is not dogma; it is to force the API boundary to be explicit and to define behavior in executable form. If a module is hard to test, it is usually also hard to reuse.

**CppUTest** is our recommended framework. It is a robust C/C++ unit testing framework that allows us to leverage the sophisticated features of C++ for creating powerful mocks and test harnesses while keeping the production code in pure C.

### Unit Testing Standards

<convention id="UT-01" title="Test Organization">

**Standard**: Each library must have a `tests/` folder. Inside, each public module must have a corresponding test file under `tests/srctest/` named `moduleNameTests.cpp`, and that file must test the module's public API.

**Rationale**: A 1:1 mapping between modules and test suites makes it easy to find coverage, makes it harder to "forget tests", and keeps test intent close to the module's API design.

**Detail**: If a module exposes five public functions, the test suite should at least cover the expected usage path, error paths, and boundary conditions for each function. Private helper logic is tested indirectly through the public API.

**Example**:

```text
companion_code/ch3_patterns/
├── include/
│   └── registry.h
├── src/
│   └── registry.c
└── tests/
    └── srctest/
        └── registryTests.cpp
```

</convention>

<convention id="UT-02" title="Test Folder Structure">

**Standard**: The `tests/` folder should follow a consistent internal structure:

- `build/`: Test build configuration (makefiles/tooling configs; tracked).
- `out/`: Test build outputs (generated; gitignored).
- `srctest/`: The CppUTest test sources (`*Tests.cpp`) and the runner translation unit (e.g., `AllTests.cpp`).
- `helpers/`: Shared test utilities (builders, fixtures, common assertions).
- `mocks/`: Mock implementations used by unit tests.
- `stubs/`: Stub implementations used by unit tests.

**Rationale**: A predictable structure keeps the test harness maintainable as it grows and makes it obvious where a new test, helper, stub, or mock should live.

**Detail**: The names are intentionally literal:

* `helpers/` holds reusable test code that is not pretending to be a production dependency.
* `mocks/` and `stubs/` hold test doubles that stand in for dependencies.
* `srctest/` stays focused on test cases and the runner.

**Example**:

```text
tests/
├── build/                 # Build configuration (tracked)
├── helpers/               # Test-only helpers
├── mocks/                 # Mock dependencies
├── out/                   # Generated output (gitignored)
├── srctest/               # Test suites + AllTests.cpp
└── stubs/                 # Stub dependencies
```

</convention>

<convention id="UT-03" title="Build and Test Automation Scripts">

**Standard**: Each library should include a `build/` folder at the library root containing:

- `run_tests.sh`: A shell script for configuring, building, and running tests on Linux (the single source of truth).
- `invoke_wsl_tests.ps1`: A PowerShell wrapper that invokes the Linux script through WSL on Windows.

**Detail**: Use **WSL as the common base environment** for both Windows and Linux development. The Windows PowerShell script should simply call the Linux script through WSL, rather than duplicating logic. This ensures a single source of truth for the build process. Scripts should handle path resolution, CPPUTEST_HOME detection, and build directory management automatically. See `companion_code/ch3_patterns/build/` for reference implementations.

**Rationale**: Having a single Linux-based script as the source of truth eliminates duplication and ensures identical behavior across Windows (via WSL), Linux, and CI environments. This approach was discovered through experience—it significantly reduces maintenance burden and prevents platform-specific bugs.

**Example**:

```text
companion_code/ch3_patterns/
├── build/
│   ├── invoke_wsl_tests.ps1
│   └── run_tests.sh
└── tests/
    └── build/
```

</convention>

<convention id="UT-04" title="Test Independence">

**Standard**: Each test must be self-contained and must not depend on the state or side effects of other tests. `setup` and `teardown` must establish a clean state for every test.

**Rationale**: Prevents cascading failures and ensures that tests can be run in any order.

**Detail**: If a module uses global/static state (common in embedded), provide explicit reset functions for tests or design the API so state is encapsulated behind a handle (see `NC-04`). If a dependency provides time, randomness, or I/O, tests must control that dependency (via a stub/mock) so results are deterministic.

</convention>

<convention id="UT-05" title="Arrange, Act, Assert">

**Standard**: Test bodies should clearly follow the **AAA** pattern:

1. **Arrange**: Setup the state.
2. **Act**: Call the function under test.
3. **Assert**: Verify the results.

**Rationale**: Improves readability and standardizes test logic.

**Example**:

```cpp
TEST(Registry, Register_NullSelf_ReturnsError)
{
    // Arrange
    registry_status_t status = REGISTRY_STATUS_OK;

    // Act
    status = registry_register(NULL, "name", (void*)0x1234);

    // Assert
    CHECK_EQUAL(REGISTRY_STATUS_INVALID_ARG, status);
}
```

</convention>

<convention id="UT-06" title="Test Naming">

**Standard**: Test names should follow a pattern like `FunctionOrFeature_Condition_ExpectedResult` (e.g., `Init_NullPointer_ReturnsError`).

**Rationale**: Makes failures self-explanatory in the test report.

**Detail**: Prefer concrete conditions over vague ones. "NullPointer" is better than "Invalid"; "FullBuffer" is better than "EdgeCase". If you need multiple assertions for the same scenario, group them into one test only if they describe a single behavior.

</convention>

<convention id="UT-07" title="Living Documentation">

**Standard**: Unit tests should serve as executable documentation. They should demonstrate the recommended usage, edge cases, and limits of the module.

**Rationale**: Unlike comments, compiled tests cannot drift out of sync with the code.

**Detail**: A new developer should be able to read `*Tests.cpp` and learn how the API is intended to be called, what inputs are valid, and what failures look like. If your tests read like a usage guide, your API is probably shaped well.

</convention>

<convention id="UT-08" title="Test Helpers">

**Standard**: Shared setup code and complex assertions should be abstracted into helper functions or "Test Objects". These should be located in `tests/helpers/` and included as needed.

**Rationale**: Keep valid test functions focused on the AAA pattern and free of clutter.

**Detail**: Helpers are a pressure valve. Use them when (a) multiple test files repeat the same setup, or (b) a correct assertion needs non-trivial decoding. Do not hide the core Arrange/Act/Assert flow inside helpers.

</convention>

<convention id="UT-09" title="CppUTest Template">

**Standard**: Follow this standard template for new test files:

```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "module_under_test.h"
    // Mocks and other dependencies
}

TEST_GROUP(Module) {
    void setup() {
        module_init();
    }

    void teardown() {
        module_deinit();
    }
};

TEST(Module, Init_StateIsReset) {
    // Arrange
    // Act
    // Assert
}

```

**Rationale**: Provides a consistent starting point for all developers.

**Detail**: Keep the include order in the test file consistent as well: CppUTest headers first, then `extern "C"` with the module under test, then test doubles. Treat the test group name as part of the test report API: short, stable, and module-oriented.

</convention>

These conventions focus on unit-level verification: fast, deterministic tests that lock down behavior and make refactoring safe.
