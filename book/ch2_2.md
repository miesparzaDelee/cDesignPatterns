## Unit Testing and Verification

### Philosophy and Tooling

Verification is not an afterthought; it is part of the design work. In an embedded codebase, the fastest development loop is the one that runs on your machine, without waiting for a board, a debugger, or a flaky test rig. Unit tests keep that loop tight while still building confidence that behavior stays correct over time.

We advocate for **Test-Driven Development (TDD)**, where tests are written before the implementation. The point is not dogma; it is to force the API boundary to be explicit and to define behavior in executable form. If a module is hard to test, it is usually also hard to reuse.

**CppUTest** is our recommended framework. It is a robust C/C++ unit testing framework that allows us to leverage the sophisticated features of C++ for creating powerful mocks and test harnesses while keeping the production code in pure C.

### Unit Testing Standards

<convention id="UT-01" title="Test Organization">

**Standard**: Each library must have a `tests/` folder. Inside, each public module must have a corresponding test file under `tests/srctest/` named `moduleNameTests.cpp`, and that file must test the module's public API.

**Rationale**: A 1:1 mapping between modules and test suites makes it easy to find coverage, makes it harder to "forget tests", and keeps test intent close to the module's API design.

library_name/
├── include/
│   └── registry.h
├── src/
│   └── registry.c
└── tests/
    └── srctest/
        └── registryTests.cpp

```

</convention>

<convention id="UT-02" title="Test Folder Structure">

**Standard**: The `tests/` folder should follow a consistent internal structure:

- `build/`: Test build configuration (makefiles/tooling configs; tracked).
- `out/`: Test build outputs (generated; gitignored).
- `srctest/`: The CppUTest test sources (`*Tests.cpp`) and the runner translation unit (e.g., `AllTests.cpp`).
- `helpers/`: Shared test utilities (builders, fixtures, common assertions).
- `mocks/`: Mock implementations used by unit tests.
- `stubs/`: Stub implementations used by unit tests.

**Rationale**: A predictable structure keeps the test harness maintainable as it grows and makes it obvious where a new test, helper, stub, or mock should live.

**Detail**: The names are intentionally literal:

- `helpers/` holds reusable test code that is not pretending to be a production dependency.
- `mocks/` and `stubs/` hold test doubles that stand in for dependencies.
- `srctest/` stays focused on test cases and the runner.

**Example**:

```text
tests/
├── build/                 # Build configuration (tracked)
├── helpers/               # Test-only helpers
├── mocks/                 # Mock dependencies
├── out/                   # Generated output (gitignored)
├── srctest/               # Test suites + AllTests.cpp
└── stubs/                 # Stub dependencies
```

</convention>

<convention id="UT-03" title="Build and Test Automation Scripts">

**Standard**: Each library should include a `build/` folder at the library root containing **the scripts that are the source of truth for invoking unit tests** (CI, local terminal, and IDE tasks). Keep this separate from `tests/build/`, which is reserved for test build configuration (e.g., Makefiles).

**Detail**: Provide at least one canonical script (often a POSIX shell script) and add thin wrappers for other platforms/entrypoints as needed (PowerShell, `.bat`, CI job steps). Avoid duplicating build logic across scripts; prefer wrappers that delegate to the canonical script or a shared helper. Scripts should handle path resolution and tool/dependency discovery so a developer can run tests with a single command.

**Rationale**: A single, discoverable entrypoint for running tests reduces onboarding friction and prevents the "works on my machine" drift between CI, local terminal use, and IDE-run configurations.

**Example**:

(For a concrete example, see `companion_code/ch3_patterns/build/` which demonstrates CppUTest test invocation via a Linux script plus a Windows wrapper.)

```text
library/
├── build/                 # Automation entrypoints (tracked)
│   ├── run_tests.sh
│   └── run_tests.ps1
└── tests/
    └── build/             # Build configuration (tracked)
```

</convention>

<convention id="UT-04" title="Test Independence">

**Standard**: Every test must run in any order. A test must leave the process in the same state it found it.

**Rationale**: Prevents cascading failures and makes CI/local/IDE runs consistent.

**Detail**:

- Put the "global reset" in a helper (fakes, singletons, static state).
- Call that helper from each group's `setup`/`teardown`.
- If some tests need a different configuration (capacity, wiring, feature flags), put them in a separate `TEST_GROUP` with its own fixture so those assumptions never mix.

If a design requires global/static state, provide an explicit reset API for tests or encapsulate the state behind a handle (see `NC-04`). If a dependency provides time, randomness, or I/O, tests must control it (stub/mock) so results are deterministic.

**Example**:

```cpp
// Shared reset for anything process-global.
static void reset_test_world(void)
{
    fake_time_reset();
    fake_io_reset();
}

// Tests in this group assume the default configuration.
TEST_GROUP(Registry_Default)
{
    registry_t reg;

    void setup() override
    {
        reset_test_world();
        registry_init(&reg);
    }

    void teardown() override
    {
        registry_deinit(&reg);
        reset_test_world();
    }
};

// Tests in this group assume a larger capacity; keeping them separate prevents
// conflicts with default-capacity assumptions.
TEST_GROUP(Registry_LargeCapacity)
{
    registry_t reg;

    void setup() override
    {
        reset_test_world();
        registry_init_with_capacity(&reg, 128);
    }

    void teardown() override
    {
        registry_deinit(&reg);
        reset_test_world();
    }
};

TEST(Registry_Default, RegisterAndLookup_Works)
{
    registry_register(&reg, "alpha", (void*)0x1234);
    CHECK_EQUAL((void*)0x1234, registry_lookup(&reg, "alpha"));
}

TEST(Registry_LargeCapacity, RegisterMany_DoesNotFail)
{
    // This test would be noisy/fragile if it ran in the default-capacity group.
    for (int i = 0; i < 100; ++i) {
        registry_register(&reg, "name", (void*)0x1234);
    }
}
```

</convention>

<convention id="UT-05" title="Arrange, Act, Assert">

**Standard**: Test bodies should clearly follow the **AAA** pattern:

1. **Arrange**: Setup the state.
2. **Act**: Call the function under test.
3. **Assert**: Verify the results.

**Rationale**: Improves readability and standardizes test logic.

**Example**:

```cpp
TEST(Registry, Register_NullSelf_ReturnsError)
{
    // Arrange
    registry_status_t status = REGISTRY_STATUS_OK;

    // Act
    status = registry_register(NULL, "name", (void*)0x1234);

    // Assert
    CHECK_EQUAL(REGISTRY_STATUS_INVALID_ARG, status);
}
```

</convention>

<convention id="UT-06" title="Test Naming">

**Standard**: Test names should follow a pattern like `FunctionOrFeature_Condition_ExpectedResult` (e.g., `Init_NullPointer_ReturnsError`).

**Rationale**: Makes failures self-explanatory in the test report.

**Detail**: Prefer concrete conditions over vague ones. "NullPointer" is better than "Invalid"; "FullBuffer" is better than "EdgeCase". If you need multiple assertions for the same scenario, group them into one test only if they describe a single behavior.

Use a consistent verb for the expectation:

- `ReturnsX` for status codes, pointers, or values.
- `SetsX` / `DoesNotChangeX` for stateful behavior.
- `EmitsX` / `CallsX` when verifying an interaction via a mock.

**Example**:

```cpp
// Good: the failure report tells you exactly what broke.
TEST(Registry, Init_NullSelf_ReturnsInvalidArg)
{
    CHECK_EQUAL(REGISTRY_STATUS_INVALID_ARG, registry_init(NULL, 8));
}

TEST(Registry, Register_DuplicateName_ReturnsAlreadyExists)
{
    registry_init(&reg, 8);
    registry_register(&reg, "alpha", (void*)0x1234);

    CHECK_EQUAL(REGISTRY_STATUS_ALREADY_EXISTS,
                registry_register(&reg, "alpha", (void*)0x9999));
}

TEST(Registry, Lookup_MissingName_ReturnsNull)
{
    registry_init(&reg, 8);
    CHECK_EQUAL((void*)0, registry_lookup(&reg, "missing"));
}

// Avoid: names that force you to open the test to learn the scenario.
// TEST(Registry, BadInput)
// TEST(Registry, EdgeCase)
// TEST(Registry, Works)
```

</convention>

<convention id="UT-07" title="Living Documentation">

**Standard**: Unit tests should serve as executable documentation. They should demonstrate the recommended usage, edge cases, and limits of the module.

**Rationale**: Unlike comments, compiled tests cannot drift out of sync with the code.

**Detail**: A new developer should be able to read `*Tests.cpp` and learn how the API is intended to be called, what inputs are valid, and what failures look like. If your tests read like a usage guide, your API is probably shaped well.

If the module permits, keep one small "usage" group (or a single `usage_example` test) that reads like the code you would write in `main()`. These tests are not trying to exhaustively cover every edge case; they demonstrate the intended happy-path call sequence and the meaning of common return values. For this specific style, readability can matter more than strictly following AAA.

**Example**:

```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "registry.h"
}

TEST_GROUP(Registry)
{
};

TEST(Registry, usage_example)
{
    // 1. Initialize
    registry_t reg = {};
    CHECK_EQUAL(REGISTRY_STATUS_OK, registry_init(&reg, 8));

    // 2. Register values
    CHECK_EQUAL(REGISTRY_STATUS_OK, registry_register(&reg, "alpha", (void*)0x1234));
    CHECK_EQUAL(REGISTRY_STATUS_OK, registry_register(&reg, "beta",  (void*)0xBEEF));

    // 3. Lookup and use
    CHECK_EQUAL((void*)0x1234, registry_lookup(&reg, "alpha"));
    CHECK_EQUAL((void*)0,      registry_lookup(&reg, "missing"));

    // 4. Cleanup
    registry_deinit(&reg);
}
```

</convention>

<convention id="UT-08" title="Test Helpers">

**Standard**: Shared setup code and complex assertions should be abstracted into helper functions or "Test Objects". These should be located in `tests/helpers/` and included as needed.

**Rationale**: Keep valid test functions focused on the AAA pattern and free of clutter.

**Detail**: Helpers are a pressure valve. Use them when (a) multiple test files repeat the same setup, or (b) a correct assertion needs non-trivial decoding. Do not hide the core Arrange/Act/Assert flow inside helpers.

When a test file grows and many tests repeat the same sequences, prefer a small, module-specific helper pair like `tests/helpers/<module>TestHelper.h` + `tests/helpers/<module>TestHelper.cpp`. This keeps individual tests short while still reading like a usage example.

Good helper targets:

- Common setup steps ("given" helpers): initialize, create a default config, populate a small fixture.
- Complex assertions ("then" helpers): decode packed bitfields, compare structs, validate an ordered list.

Avoid:

- A single helper that performs Arrange+Act+Assert for the whole test (it hides what behavior is being verified).

**Example**:

`tests/helpers/RegistryTestHelper.h`

```cpp
#pragma once

extern "C" {
    #include "registry.h"
}

void givenRegistryInitialized(registry_t* reg, int capacity);
void thenRegistryLookupIs(registry_t* reg, const char* name, void* expected);
```

`tests/helpers/RegistryTestHelper.cpp`

```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "registry.h"
}

void givenRegistryInitialized(registry_t* reg, int capacity)
{
    CHECK_EQUAL(REGISTRY_STATUS_OK, registry_init(reg, capacity));
}

void thenRegistryLookupIs(registry_t* reg, const char* name, void* expected)
{
    CHECK_EQUAL(expected, registry_lookup(reg, name));
}
```

`tests/srctest/registryTests.cpp`

```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "registry.h"
}

#include "helpers/RegistryTestHelper.h"

TEST_GROUP(Registry)
{
    registry_t reg;

    void teardown()
    {
        registry_deinit(&reg);
    }
};

TEST(Registry, RegisterThenLookup_ReturnsSamePointer)
{
    givenRegistryInitialized(&reg, 8);
    registry_register(&reg, "alpha", (void*)0x1234);

    thenRegistryLookupIs(&reg, "alpha", (void*)0x1234);
}
```

</convention>

<convention id="UT-09" title="CppUTest Template">

**Standard**: Follow this standard template for new test files:

```cpp
#include "CppUTest/TestHarness.h"

extern "C" {
    #include "module_under_test.h"
    // Mocks/stubs for dependencies (if needed)
}

// Optional module-specific helpers (see UT-08)
// #include "helpers/ModuleTestHelper.h"

TEST_GROUP(Module_Usage)
{
    void setup() {
        module_init();
    }

    void teardown() {
        module_deinit();
    }
};

TEST(Module_Usage, usage_example)
{
    // Write this like you would in main() (see UT-07)
    // 1. Initialize
    // 2. Call the API in order
    // 3. Check the key outcomes
}

TEST_GROUP(Module_Errors)
{
    void setup() {
        module_init();
    }

    void teardown() {
        module_deinit();
    }
};

TEST(Module_Errors, Init_NullPointer_ReturnsInvalidArg)
{
    // Arrange / Act / Assert (UT-05)
}

```

**Rationale**: Provides a consistent starting point for all developers.

**Detail**: Keep the include order consistent: CppUTest headers first, then `extern "C"` with the module under test and any C test doubles, then optional `tests/helpers/*TestHelper.h`. When a module has multiple distinct behaviors, split tests into multiple `TEST_GROUP`s by functionality (e.g., `Module_Usage`, `Module_Errors`, `Module_LargeCapacity`) and keep the tests for each group clustered right after the group.

</convention>

These conventions focus on unit-level verification: fast, deterministic tests that lock down behavior and make refactoring safe.
