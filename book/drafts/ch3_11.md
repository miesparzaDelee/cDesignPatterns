## Intrusive Boundary Listener Pattern

### Overview

**N:N notifications using embedded nodes**. Unlike 3.9 and 3.10 where callbacks are stored in static arrays, this pattern embeds the listener node directly into the listener's data structure. This allows unlimited listeners with zero allocation overhead.

### Current Design Discussion

**Pattern Goal:** Detect when shapes cross canvas boundaries and notify multiple listeners.

#### Option A: Pre-defined Listener (Simpler, No CONTAINER_OF)

```c
/* Canvas defines the listener struct */
typedef struct canvas_boundary_listener {
    struct canvas_boundary_listener *next;  /* Canvas links these */
    void (*onBoundaryCrossed)(struct canvas_boundary_listener *listener,
                              api_shape_t *shape,
                              int16_t x, int16_t y,
                              canvas_edge_t edge);
    void *user_context;  /* Your data */
} canvas_boundary_listener_t;

/* Usage - direct access, simple */
void my_callback(canvas_boundary_listener_t *listener, ...) {
    void *my_data = listener->user_context;
}
```

**Pros:** Simple, no CONTAINER_OF needed, educational for basic intrusive pattern  
**Cons:** Canvas defines the struct, less flexible

#### Option B: Embedded Node with CONTAINER_OF (More Educational)

```c
/* Just the node - you embed this */
typedef struct canvas_boundary_listener_node {
    struct canvas_boundary_listener_node *next;
} canvas_boundary_listener_node_t;

/* You define your own struct */
typedef struct {
    canvas_boundary_listener_node_t node;  /* Embed the node */
    void (*onBoundaryCrossed)(canvas_boundary_listener_node_t *node, ...);
    void *user_context;
} my_listener_t;

/* Usage - requires CONTAINER_OF */
void my_callback(canvas_boundary_listener_node_t *node, ...) {
    my_listener_t *self = CONTAINER_OF(node, my_listener_t, node);
    void *my_data = self->user_context;
}
```

**Pros:** Demonstrates CONTAINER_OF, true intrusive pattern, flexible  
**Cons:** More complex, requires understanding CONTAINER_OF macro

#### Canvas Integration

**Canvas boundaries:**
- Hardcoded: (0,0) to (200,200) for simplicity
- Or configurable in canvas_config_t

**API additions to canvas.h:**
```c
typedef enum {
    CANVAS_EDGE_LEFT,
    CANVAS_EDGE_RIGHT,
    CANVAS_EDGE_TOP,
    CANVAS_EDGE_BOTTOM
} canvas_edge_t;

void canvas_addBoundaryListener(canvas_boundary_listener_t *listener);
void canvas_removeBoundaryListener(canvas_boundary_listener_t *listener);
```

**canvas_task() logic:**
```c
void canvas_task(void) {
    for each shape:
        if (moving) {
            update_position();
            
            /* 3.10 - position listener */
            if (positionListenerEnabled)
                positionListener(shape, x, y, context);
            
            /* 3.11 - boundary check */
            if (crossed_boundary(x, y)) {
                for each boundary_listener:
                    listener->onBoundaryCrossed(listener, shape, x, y, edge);
            }
            
            /* 3.9 - move complete callback */
            if (!moving && moveCallback)
                moveCallback(shape, context);
        }
}
```

### Key Decisions Needed

1. **Option A or B?**
   - A: Simpler, no CONTAINER_OF
   - B: More educational, shows CONTAINER_OF pattern

2. **Boundary definition:**
   - Hardcoded 0-200 range
   - Or configurable in canvas_config_t

3. **Callback signature:**
   - Include `void *context` parameter?
   - Or rely on listener struct only?

### Implementation Status

**Files:**
- `include/canvas.h` - Has placeholders for 3.11 types
- `src/canvas.c` - Has canvas_task() ready for boundary check
- `tests/srctest/canvasTests.cpp` - 28 tests passing (13 canvas tests)

**Next Steps:**
1. Decide on Option A vs B
2. Add boundary_listener typedef to canvas.h
3. Implement intrusive linked list in canvas.c
4. Add boundary checking logic in canvas_task()
5. Write tests
6. Update book text with literate programming tags

### Comparison with Previous Patterns

| Pattern | Storage | Who Allocates | Flexibility | Use Case |
|---------|---------|---------------|-------------|----------|
| 3.9 Simple | Module array | Module | One callback | Completion events |
| 3.10 Observer | Module array | Module | One callback, many calls | Continuous monitoring |
| 3.11 Intrusive | Linked list | **User** | Unlimited listeners | Complex event systems |

**Unique to 3.11:** User allocates listener structs, embeds node, module only manages links.

### Open Questions

- Should we demonstrate CONTAINER_OF (Option B) for educational value?
- Or keep it simple (Option A) to focus on the concept?
- Is boundary detection the right example, or should we use something else?

### Next Session Plan

1. Review and decide on design approach
2. Add boundary_listener types to canvas.h
3. Implement intrusive list operations
4. Add boundary detection to canvas_task()
5. Create tests and usage example
6. Update book text
