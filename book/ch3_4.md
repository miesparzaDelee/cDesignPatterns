## Private Pattern

### Pattern Description

The Private Pattern strikes a balance between the Object Pattern and the Opaque Pattern, combining elements of both.
Like the Object Pattern, it allows **static allocation** and exposes the struct definition.
Like the Opaque Pattern, it **hides implementation details** from users.

The key innovation is the use of a **private header file** that defines internal data structures.
This private header is included by the public header, allowing the struct to contain private fields without exposing their details to users.
Users can see that private data exists (in the `_private` field), but cannot access its contents without deliberately including the private header—which they are conventionally discouraged from doing.

#### **Key Use Cases**

- Systems requiring **static memory allocation** (embedded, real-time, resource-constrained environments)
- Modules needing **some encapsulation** without the overhead of full opacity
- Situations where you want **testability** of internal state through private helper functions
- Balancing **performance** (direct struct access) with **maintainability** (hidden implementation)

#### **Benefits**

- **Static allocation**: Users can allocate objects on the stack or in static memory, avoiding dynamic allocation overhead
- **Selective visibility**: Public fields (like `area`) are readable; private fields (like `base`, `height`) are hidden
- **Testability**: Private helper functions can be declared in the private header for testing internal state
- **Flexibility**: Internal implementation can change without affecting users who follow conventions

#### **Drawbacks**

- **Additional header file**: Requires maintaining a separate private header (`*Private.h`)
- **Convention-based protection**: The pattern relies on users **not** including the private header or accessing `_private` fields directly—this is a convention, not compiler-enforced
- **Slightly more complex**: More moving parts than pure Object or Opaque patterns
- **Trust required**: Users must be disciplined and respect the public/private boundary

### **Implementation**

#### **Header Files**

Let's use a **Triangle** as our example, demonstrating the Private Pattern's unique structure.

The Private Pattern requires **two header files**: a public one and a private one.

**Critical ordering**: The public header must include the private header **before** defining the struct.

{{ file "companion_code/ch3_patterns/include/triangle.h" type="whole" }}

Notice the structure:

1. Forward declaration of `struct triangle`
2. Handle typedef `hTriangle_t` (following convention NC-04)
3. **Include private header** - this must come before the struct definition
4. Struct definition with public `const float area` and private `_triangle_private_t _private`

The private header defines what goes inside the `_private` field:

{{ file "companion_code/ch3_patterns/include/trianglePrivate.h" type="whole" }}

The `_triangle_private_t` struct contains `base` and `height`—hidden from users.
The underscore prefix (`_`) is a convention indicating this is private data.

The private header can also declare **private helper functions** for testing:

```c
_triangle_private_t* triangle_getPrivateInfo(hTriangle_t self);
```

This function is not in the public header, so normal users won't see it.
But test code can include the private header to access internal state for verification.

#### **Source File**

The source file implements both public and private functions:

{{ file "companion_code/ch3_patterns/src/triangle.c" type="whole" }}

Key points:

- Public functions (`triangle_init`, `triangle_updateDimensions`) access `self->_private.base` and `self->_private.height` directly
- The public `area` field is updated using pointer casting: `*(float *)&self->area`
- The private helper function `triangle_getPrivateInfo` returns a pointer to the private data for testing

### **Example Usage**

Below is an actual unit test demonstrating how users interact with the triangle:

{{ file "companion_code/ch3_patterns/tests/srctest/triangleTests.cpp" type="test" name="Triangle_PrivatePattern,demonstrates_PrivateFieldAccess" }}

The test shows:

- Users can read the public `area` field directly
- Users **cannot** access `base` or `height` without including the private header
- Test code includes the private header and uses `triangle_getPrivateInfo()` to verify internal state

This demonstrates the pattern's key benefit: **public interface with private implementation**, while still supporting static allocation and targeted testing.
