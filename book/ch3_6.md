## VTable Pattern

### Pattern Description

The VTable (Virtual Table) pattern provides a mechanism for runtime polymorphism, similar to virtual functions in C++. It allows objects of different types to be treated uniformly through a common interface, where the specific behavior is determined at runtime based on the object's type.

This is achieved by defining a structure of function pointers (the "vtable"). The base object holds a pointer (`vptr`) to this table. when a function is called on the base interface, it looks up the specific function in the table and executes it.

#### **Key Use Cases**

- **Drivers**: A common `driver_api_t` interface for different hardware (e.g., `SPI`, `I2C`, `UART`).
- **Plugins**: Loading different behaviors dynamically.
- **State Machines**: Swapping the vtable pointer to change an object's behavior (e.g., from "Idle" to "Connected").

#### **Benefits**

- **Decoupling**: The user of the interface does not need to know the implementation details or the specific type of the object.
- **Flexibility**: Behavior can be changed at runtime by simply pointing the `vptr` to a different table.
- **Extensibility**: New types can be added without modifying the existing interface code.

#### **Drawbacks**

- **Performance**: There is a slight overhead due to double indirection (pointer to object -> pointer to vtable -> pointer to function).
- **Complexity**: Debugging can be harder because "Go To Definition" usually leads to the interface wrapper, not the concrete implementation.

### Implementation

#### **Header Files**

The implementation requires a **VTable definition** (the contract) and a **Base API structure** that holds the pointer to it.

{{ file "companion_code/ch3_patterns/include/api_shape.h" type="whole" }}

Notice that `api_shape_t` inherits from `shape_t` (Family Pattern) but adds the `vptr` member.

#### **Source Files**

The "Magic" happens in two places:

1. **The Wrappers (`src/api_shape.c`)**: These functions perform the lookup and dispatch.

    ```c
    void shape_draw(api_shape_t *self)
    {
        // Check if vptr and function exist, then call
        if (self && self->vptr && self->vptr->draw) {
            self->vptr->draw(self);
        }
    }
    ```

2. **The Concrete Implementation (`src/api_rectangle.c`)**: Defines the specific behavior and the static vtable.

{{ file "companion_code/ch3_patterns/src/api_rectangle.c" type="whole" }}

Note that `rectangle_vtable` is `static const`. It is shared by all instances of `api_rectangle_t`, saving memory compared to storing function pointers in every object.

### Example Usage

The following example demonstrates full **Polymorphism** with three different shapes. The `shapes` array treats them all as generic `api_shape_t*`, but calling `shape_get_area` invokes the specific logic for each one.

{{ file "companion_code/ch3_patterns/tests/srctest/vtableTests.cpp" type="test" name="VTablePattern,Polymorphism" }}

This pattern is powerful because the `shapes` array processing loop never needs to change, even if we add a new shape type like `Polygon` or `Star` in the future.
